\section{Evaluation}
\label{sec:evaluation}

Due to the nature of our project, i.e. an offline fault-tolerant client-server Web browser API, our evaluation will be twofold: \textit{(1)} comparing the network traffic induced by a Web app built on our framework, to a traditional client-server version; and \textit{(2)} evaluating the robustness to failure of our framework.

\subsection{Traffic comparison}

First, we want to measure network traffic in this offline network and compare it against a traditional client-server Web application. 
Despite having different network characteristics (local-area vs Internet), this comparison will help us to identify and discuss possible benefits and drawbacks of our approach.

We will monitor traffic at the packet level using an implementation of the \texttt{pcap} API to measure network traffic.
Traffic will be measured for an application running in {\it (i)} a traditional client-server architecture, {\it (ii)} a default FlyWeb implementation, and also {\it (iii)} in our fault-tolerant API. 
We aim to compare traffic in each one of these scenarios and discuss their differences. 
For the traditional client-server vs. FlyWeb comparison, our purpose is to evaluate differences in delay, while for the within-FlyWeb comparison, we want to compare network overhead generated by our fault-tolerance strategy. 

\subsection{Robustness to failures}

Second, we want to measure network traffic in the face of failures.
How much network traffic is required to achieve stability once a server device fails? 
How long does it take for this stability to be achieved?
Is our approach to fault-tolerance scalable? 
These are some of the questions that we want to answer with the second evaluation.

As for our second evaluation, we will write scripts that simulate client connecting to a server device through our \texttt{\APIName} API. 
Once a set of clients establish communication, our simulation will then remove the server device from the network such that we can evaluate how \texttt{\APIName} handles failures. 

Regarding our simulations, we will consider a queue system as a baseline application.
The queue will have $i$ configurable consumers, and $j$ configurable producers which will produce-consume queue entries at random given times. 
Such entries will also have a configurable payload size. 
Such system will give us a local-area network with $n = i + j$ devices, and it will also allow us to experiment with different size configurations. 
For instance, we can compare scenarios with a small, medium, or large number of devices connected.
